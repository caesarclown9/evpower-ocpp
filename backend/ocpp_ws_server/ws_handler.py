"""
OCPP 1.6 WebSocket Handler - –ü–æ–ª–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ best practice
–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è: Tier 1, 2, 3 (–≤—Å–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ OCPP 1.6)
"""

import asyncio
import logging
from datetime import datetime
from typing import Dict, Any, Optional

from fastapi import WebSocket, WebSocketDisconnect
from ocpp.v16 import ChargePoint as CP
from ocpp.routing import on
from ocpp.v16 import call_result, call
from ocpp.v16.enums import (
    RegistrationStatus, AuthorizationStatus, ConfigurationStatus,
    ResetStatus, ResetType, UnlockStatus, AvailabilityStatus,
    AvailabilityType, ClearCacheStatus, UpdateStatus,
    DiagnosticsStatus, FirmwareStatus, TriggerMessageStatus,
    MessageTrigger, UpdateType
)

from .redis_manager import redis_manager
from app.db.session import get_db
from app.crud.ocpp_service import (
    OCPPStationService,
    OCPPTransactionService,
    OCPPMeterService,
    OCPPAuthorizationService,
    OCPPConfigurationService
)
from app.db.models.ocpp import OCPPTransaction
from sqlalchemy import text

logger = logging.getLogger(__name__)

# –ê–∫—Ç–∏–≤–Ω—ã–µ —Å–µ—Å—Å–∏–∏ –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –ª–∏–º–∏—Ç–æ–≤
active_sessions: Dict[str, Dict[str, Any]] = {}

class OCPPChargePoint(CP):
    """
    –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π OCPP 1.6 ChargePoint —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –≤—Å–µ—Ö —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
    """
    
    def __init__(self, id: str, connection):
        super().__init__(id, connection)
        self.logger = logging.getLogger(f"OCPP.{id}")
        
    # ============================================================================
    # TIER 1: –ö–†–ò–¢–ò–ß–ï–°–ö–ò –í–ê–ñ–ù–´–ï (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –¥–ª—è —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏)
    # ============================================================================
    
    @on('BootNotification')
    def on_boot_notification(self, charge_point_model, charge_point_vendor, **kwargs):
        """–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —Å—Ç–∞–Ω—Ü–∏–∏ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ"""
        self.logger.info(f"BootNotification: {charge_point_model}, {charge_point_vendor}")
        
        try:
            with next(get_db()) as db:
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å—Ç–∞–Ω—Ü–∏–∏
                firmware_version = kwargs.get('firmware_version')
                OCPPStationService.mark_boot_notification_sent(
                    db, self.id, firmware_version
                )
                
                # –ë–∞–∑–æ–≤–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
                OCPPConfigurationService.set_configuration(
                    db, self.id, "HeartbeatInterval", "300", readonly=True
                )
                OCPPConfigurationService.set_configuration(
                    db, self.id, "MeterValueSampleInterval", "60", readonly=True
                )
                
                # üÜï –ê–í–¢–û–ó–ê–ü–£–°–ö: –ü—Ä–æ–≤–µ—Ä—è–µ–º pending —Å–µ—Å—Å–∏–∏
                pending_sessions_query = text("""
                    SELECT id, user_id, limit_value, limit_type
                    FROM charging_sessions 
                    WHERE station_id = :station_id 
                    AND status = 'started' 
                    AND transaction_id IS NULL
                """)
                
                pending_sessions = db.execute(pending_sessions_query, {"station_id": self.id}).fetchall()
                
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–º–∞–Ω–¥—ã –∞–≤—Ç–æ–∑–∞–ø—É—Å–∫–∞ –¥–ª—è –∫–∞–∂–¥–æ–π pending —Å–µ—Å—Å–∏–∏
                for session in pending_sessions:
                    session_id, user_id, limit_value, limit_type = session
                    id_tag = f"CLIENT_{user_id}"
                    
                    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä –∏–∑ –∑–∞–Ω—è—Ç—ã—Ö –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–æ–≤
                    connector_query = text("""
                        SELECT connector_number FROM connectors 
                        WHERE station_id = :station_id AND status = 'occupied'
                        LIMIT 1
                    """)
                    connector_result = db.execute(connector_query, {"station_id": self.id}).fetchone()
                    connector_id = connector_result[0] if connector_result else 1
                    
                    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–º–∞–Ω–¥—É –∞–≤—Ç–æ–∑–∞–ø—É—Å–∫–∞ —á–µ—Ä–µ–∑ Redis
                    command_data = {
                        "action": "RemoteStartTransaction",
                        "connector_id": connector_id,
                        "id_tag": id_tag,
                        "session_id": session_id,
                        "limit_type": limit_type,
                        "limit_value": limit_value
                    }
                    
                    # –ò—Å–ø–æ–ª—å–∑—É–µ–º asyncio –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ Redis –∫–æ–º–∞–Ω–¥—ã
                    asyncio.create_task(
                        redis_manager.publish_command(self.id, command_data)
                    )
                    
                    self.logger.info(f"üöÄ –ê–≤—Ç–æ–∑–∞–ø—É—Å–∫ –∑–∞—Ä—è–¥–∫–∏ –¥–ª—è —Å–µ—Å—Å–∏–∏ {session_id}")
                
            return call_result.BootNotification(
                current_time=datetime.utcnow().isoformat() + 'Z',
                interval=300,
                status=RegistrationStatus.accepted
            )
            
        except Exception as e:
            self.logger.error(f"Error in BootNotification: {e}")
            return call_result.BootNotification(
                current_time=datetime.utcnow().isoformat() + 'Z',
                interval=300,
                status=RegistrationStatus.rejected
            )

    @on('Heartbeat')
    def on_heartbeat(self, **kwargs):
        """–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–µ —Å–∏–≥–Ω–∞–ª—ã –∂–∏–∑–Ω–∏"""
        self.logger.debug(f"Heartbeat from {self.id}")
        
        try:
            with next(get_db()) as db:
                OCPPStationService.update_heartbeat(db, self.id)
                
            return call_result.Heartbeat(
                current_time=datetime.utcnow().isoformat() + 'Z'
            )
            
        except Exception as e:
            self.logger.error(f"Error in Heartbeat: {e}")
            return call_result.Heartbeat(
                current_time=datetime.utcnow().isoformat() + 'Z'
            )

    @on('StatusNotification')
    def on_status_notification(self, connector_id, error_code, status, **kwargs):
        """–ò–∑–º–µ–Ω–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–æ–≤"""
        self.logger.info(f"StatusNotification: connector={connector_id}, status={status}, error={error_code}")
        
        try:
            with next(get_db()) as db:
                info = kwargs.get('info')
                vendor_id = kwargs.get('vendor_id')
                vendor_error_code = kwargs.get('vendor_error_code')
                
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å —Å—Ç–∞–Ω—Ü–∏–∏ (—Å—Ç–∞—Ä–∞—è –ª–æ–≥–∏–∫–∞ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
                station_status = OCPPStationService.update_station_status(
                    db, self.id, status, error_code, info, vendor_id, vendor_error_code
                )
                
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–∞ –≤ JSON –ø–æ–ª–µ (—Å—Ç–∞—Ä–∞—è –ª–æ–≥–∏–∫–∞)
                connector_status = station_status.connector_status or []
                
                # –ù–∞—Ö–æ–¥–∏–º –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º —Å—Ç–∞—Ç—É—Å –¥–ª—è –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–∞
                connector_found = False
                for i, conn in enumerate(connector_status):
                    if conn.get('connector_id') == connector_id:
                        connector_status[i] = {
                            'connector_id': connector_id,
                            'status': status,
                            'error_code': error_code,
                            'info': info,
                            'timestamp': datetime.utcnow().isoformat()
                        }
                        connector_found = True
                        break
                
                if not connector_found:
                    connector_status.append({
                        'connector_id': connector_id,
                        'status': status,
                        'error_code': error_code,
                        'info': info,
                        'timestamp': datetime.utcnow().isoformat()
                    })
                
                station_status.connector_status = connector_status
                
                # üÜï –ù–û–í–ê–Ø –õ–û–ì–ò–ö–ê: –û–±–Ω–æ–≤–ª—è–µ–º —Ç–∞–±–ª–∏—Ü—É connectors
                # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º OCPP —Å—Ç–∞—Ç—É—Å –≤ –Ω–∞—à —Ñ–æ—Ä–º–∞—Ç
                connector_status_mapping = {
                    'Available': 'Available',
                    'Preparing': 'Occupied', 
                    'Charging': 'Occupied',
                    'SuspendedEVSE': 'Occupied',
                    'SuspendedEV': 'Occupied',
                    'Finishing': 'Occupied',
                    'Reserved': 'Occupied',
                    'Unavailable': 'Unavailable',
                    'Faulted': 'Faulted'
                }
                
                new_status = connector_status_mapping.get(status, 'Unavailable')
                
                # –û–±–Ω–æ–≤–ª—è–µ–º –∑–∞–ø–∏—Å—å –≤ —Ç–∞–±–ª–∏—Ü–µ connectors
                update_query = text("""
                    UPDATE connectors 
                    SET status = :status, error_code = :error_code, last_status_update = NOW()
                    WHERE station_id = :station_id AND connector_number = :connector_id
                """)
                db.execute(update_query, {
                    "status": new_status.lower(), 
                    "error_code": error_code, 
                    "station_id": self.id, 
                    "connector_id": connector_id
                })
                
                db.commit()
                
            return call_result.StatusNotification()
            
        except Exception as e:
            self.logger.error(f"Error in StatusNotification: {e}")
            return call_result.StatusNotification()

    @on('Authorize')
    def on_authorize(self, id_tag, **kwargs):
        """–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è RFID –∫–∞—Ä—Ç"""
        self.logger.info(f"Authorize request for id_tag: {id_tag}")
        
        try:
            with next(get_db()) as db:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é —á–µ—Ä–µ–∑ —Å–µ—Ä–≤–∏—Å
                auth_result = OCPPAuthorizationService.authorize_id_tag(db, id_tag)
                
            self.logger.info(f"Authorization result for {id_tag}: {auth_result['status']}")
            
            return call_result.Authorize(id_tag_info=auth_result)
            
        except Exception as e:
            self.logger.error(f"Error in Authorize: {e}")
            return call_result.Authorize(
                id_tag_info={"status": AuthorizationStatus.invalid}
            )

    @on('StartTransaction')
    def on_start_transaction(self, connector_id, id_tag, meter_start, timestamp, **kwargs):
        """–ù–∞—á–∞–ª–æ —Å–µ–∞–Ω—Å–∞ –∑–∞—Ä—è–¥–∫–∏"""
        self.logger.info(f"StartTransaction: connector={connector_id}, id_tag={id_tag}, meter_start={meter_start}")
        
        try:
            with next(get_db()) as db:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é
                auth_result = OCPPAuthorizationService.authorize_id_tag(db, id_tag)
                if auth_result["status"] != "Accepted":
                    self.logger.warning(f"Unauthorized id_tag: {id_tag}")
                    return call_result.StartTransaction(
                        transaction_id=0,
                        id_tag_info=auth_result
                    )
                
                # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º transaction_id
                transaction_id = int(datetime.utcnow().timestamp())
                
                # –°–æ–∑–¥–∞–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
                transaction = OCPPTransactionService.start_transaction(
                    db, self.id, transaction_id, connector_id, id_tag,
                    float(meter_start), datetime.fromisoformat(timestamp.replace('Z', ''))
                )
                
                # üÜï –°–í–Ø–ó–´–í–ê–ù–ò–ï: –û–±–Ω–æ–≤–ª—è–µ–º –º–æ–±–∏–ª—å–Ω—É—é —Å–µ—Å—Å–∏—é transaction_id
                if id_tag.startswith("CLIENT_"):
                    client_id = id_tag.replace("CLIENT_", "")
                    update_session_query = text("""
                        UPDATE charging_sessions 
                        SET transaction_id = :transaction_id
                        WHERE station_id = :station_id 
                        AND user_id = :client_id 
                        AND status = 'started' 
                        AND transaction_id IS NULL
                    """)
                    db.execute(update_session_query, {
                        "transaction_id": str(transaction_id),
                        "station_id": self.id,
                        "client_id": client_id
                    })
                    self.logger.info(f"üîó –°–≤—è–∑–∞–ª OCPP —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é {transaction_id} —Å –º–æ–±–∏–ª—å–Ω–æ–π —Å–µ—Å—Å–∏–µ–π –¥–ª—è {client_id}")
                
                # üÜï –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–û–ï –û–ë–ù–û–í–õ–ï–ù–ò–ï: –ö–æ–Ω–Ω–µ–∫—Ç–æ—Ä —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –∑–∞–Ω—è—Ç
                update_query = text("""
                    UPDATE connectors 
                    SET status = 'occupied', last_status_update = NOW()
                    WHERE station_id = :station_id AND connector_number = :connector_id
                """)
                db.execute(update_query, {"station_id": self.id, "connector_id": connector_id})
                db.commit()
                
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–µ—Å—Å–∏–∏
                active_sessions[self.id] = {
                    'transaction_id': transaction_id,
                    'meter_start': meter_start,
                    'energy_delivered': 0.0,
                    'connector_id': connector_id,
                    'id_tag': id_tag
                }
                
            self.logger.info(f"Transaction started: {transaction_id}, connector {connector_id} marked as Occupied")
            return call_result.StartTransaction(
                transaction_id=transaction_id,
                id_tag_info={"status": AuthorizationStatus.accepted}
            )
            
        except Exception as e:
            self.logger.error(f"Error in StartTransaction: {e}")
            return call_result.StartTransaction(
                transaction_id=0,
                id_tag_info={"status": AuthorizationStatus.invalid}
            )

    @on('StopTransaction')
    def on_stop_transaction(self, meter_stop, timestamp, transaction_id, **kwargs):
        """–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Å–µ–∞–Ω—Å–∞ –∑–∞—Ä—è–¥–∫–∏"""
        id_tag = kwargs.get('id_tag')
        reason = kwargs.get('reason', 'Local')
        
        self.logger.info(f"StopTransaction: transaction_id={transaction_id}, meter_stop={meter_stop}")
        
        try:
            with next(get_db()) as db:
                # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–∞
                transaction = db.query(OCPPTransaction).filter(
                    OCPPTransaction.station_id == self.id,
                    OCPPTransaction.transaction_id == transaction_id
                ).first()
                
                connector_id = transaction.connector_id if transaction else None
                
                # –ó–∞–≤–µ—Ä—à–∞–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
                transaction = OCPPTransactionService.stop_transaction(
                    db, self.id, transaction_id, float(meter_stop),
                    datetime.fromisoformat(timestamp.replace('Z', '')), reason
                )
                
                # üÜï –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–û–ï –û–ë–ù–û–í–õ–ï–ù–ò–ï: –ö–æ–Ω–Ω–µ–∫—Ç–æ—Ä —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —Å–≤–æ–±–æ–¥–µ–Ω
                if connector_id:
                    update_query = text("""
                        UPDATE connectors 
                        SET status = 'available', error_code = 'NoError', last_status_update = NOW()
                        WHERE station_id = :station_id AND connector_number = :connector_id
                    """)
                    db.execute(update_query, {"station_id": self.id, "connector_id": connector_id})
                
                db.commit()
                
                # –û—á–∏—â–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–µ—Å—Å–∏–∏
                if self.id in active_sessions:
                    del active_sessions[self.id]
                
            self.logger.info(f"Transaction completed: {transaction_id}, connector {connector_id} marked as Available")
            return call_result.StopTransaction(
                id_tag_info={"status": AuthorizationStatus.accepted}
            )
            
        except Exception as e:
            self.logger.error(f"Error in StopTransaction: {e}")
            return call_result.StopTransaction(
                id_tag_info={"status": AuthorizationStatus.invalid}
            )

    @on('MeterValues')
    async def on_meter_values(self, connector_id, meter_value, **kwargs):
        """–ü–æ–∫–∞–∑–∞–Ω–∏—è —Å—á–µ—Ç—á–∏–∫–æ–≤ —ç–Ω–µ—Ä–≥–∏–∏"""
        transaction_id = kwargs.get('transaction_id')
        self.logger.debug(f"MeterValues: connector={connector_id}, transaction_id={transaction_id}")
        
        try:
            with next(get_db()) as db:
                # –ü–∞—Ä—Å–∏–º timestamp
                timestamp_str = meter_value[0].get('timestamp')
                if timestamp_str:
                    timestamp = datetime.fromisoformat(timestamp_str.replace('Z', ''))
                else:
                    timestamp = datetime.utcnow()
                
                # –ü–∞—Ä—Å–∏–º sampled values
                sampled_values = []
                for mv in meter_value:
                    for sample in mv.get('sampledValue', []):
                        sampled_values.append({
                            'measurand': sample.get('measurand', ''),
                            'value': sample.get('value'),
                            'unit': sample.get('unit', ''),
                            'context': sample.get('context', ''),
                            'format': sample.get('format', ''),
                            'location': sample.get('location', '')
                        })
                
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–∫–∞–∑–∞–Ω–∏—è
                OCPPMeterService.add_meter_values(
                    db, self.id, connector_id, timestamp, sampled_values, transaction_id
                )
                
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ 
                try:
                    OCPPMeterService.save_meter_values(
                        db, self.id, connector_id, meter_value
                    )
                except Exception as e:
                    self.logger.error(f"Error saving meter values to DB: {e}")
                
                # –ê–∫—Ç–∏–≤–Ω–∞—è —Å–µ—Å—Å–∏—è –¥–ª—è –ª–∏–º–∏—Ç–æ–≤
                session = active_sessions.get(self.id)
                if session and sampled_values:
                    for sample in sampled_values:
                        if sample['measurand'] == 'Energy.Active.Import.Register':
                            try:
                                current_energy = float(sample['value'])
                                meter_start = session.get('meter_start', 0.0)
                                energy_delivered = current_energy - meter_start
                                session['energy_delivered'] = energy_delivered
                                
                                # üÜï –û–ë–ù–û–í–õ–ï–ù–ò–ï –ú–û–ë–ò–õ–¨–ù–û–ô –°–ï–°–°–ò–ò: –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —ç–Ω–µ—Ä–≥–∏—é –≤ charging_sessions
                                if session.get('id_tag', '').startswith("CLIENT_"):
                                    client_id = session['id_tag'].replace("CLIENT_", "")
                                    energy_kwh = energy_delivered / 1000.0  # Wh ‚Üí kWh
                                    
                                    # –ü–æ–ª—É—á–∞–µ–º —Ç–∞—Ä–∏—Ñ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ —Å—Ç–æ–∏–º–æ—Å—Ç–∏
                                    tariff_query = text("""
                                        SELECT tariff_rub_kwh FROM stations 
                                        WHERE id = :station_id
                                    """)
                                    tariff_result = db.execute(tariff_query, {"station_id": self.id}).fetchone()
                                    tariff_rub_kwh = float(tariff_result[0]) if tariff_result and tariff_result[0] else 14.95
                                    
                                    current_amount = energy_kwh * tariff_rub_kwh
                                    
                                    # –û–±–Ω–æ–≤–ª—è–µ–º –º–æ–±–∏–ª—å–Ω—É—é —Å–µ—Å—Å–∏—é
                                    update_mobile_session_query = text("""
                                        UPDATE charging_sessions 
                                        SET energy = :energy_kwh, amount = :current_amount
                                        WHERE station_id = :station_id 
                                        AND user_id = :client_id 
                                        AND status = 'started'
                                        AND transaction_id IS NOT NULL
                                    """)
                                    db.execute(update_mobile_session_query, {
                                        "energy_kwh": energy_kwh,
                                        "current_amount": current_amount,
                                        "station_id": self.id,
                                        "client_id": client_id
                                    })
                                    db.commit()
                                    
                                    self.logger.info(f"üìä –û–±–Ω–æ–≤–∏–ª –º–æ–±–∏–ª—å–Ω—É—é —Å–µ—Å—Å–∏—é: {energy_kwh:.2f} kWh, {current_amount:.2f} —Ä—É–±")
                                
                                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–æ–≤ (–µ—Å–ª–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã)
                                energy_limit = session.get('energy_limit')
                                if energy_limit and energy_delivered >= energy_limit:
                                    self.logger.warning(f"Energy limit reached: {energy_delivered} >= {energy_limit}")
                                    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–º–∞–Ω–¥—É —á–µ—Ä–µ–∑ Redis –¥–ª—è async –æ–±—Ä–∞–±–æ—Ç–∫–∏
                                    asyncio.create_task(
                                        redis_manager.publish_command(
                                            self.id, {"command": "RemoteStopTransaction"}
                                        )
                                    )
                                
                                active_sessions[self.id] = session
                                break
                            except (ValueError, TypeError):
                                continue
                
        except Exception as e:
            self.logger.error(f"Error in MeterValues: {e}")
        
        return call_result.MeterValues()

    # ============================================================================
    # TIER 1: –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï (–∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω—ã–µ)
    # ============================================================================

    @on('GetConfiguration')
    def on_get_configuration(self, **kwargs):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤"""
        keys = kwargs.get('key', [])
        self.logger.info(f"GetConfiguration request for keys: {keys}")
        
        try:
            with next(get_db()) as db:
                configurations = OCPPConfigurationService.get_configuration(
                    db, self.id, keys
                )
                
                # –§–æ—Ä–º–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç
                configuration_key = []
                unknown_key = []
                
                if keys:
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–ø—Ä–æ—à–µ–Ω–Ω—ã–µ –∫–ª—é—á–∏
                    found_keys = {config.key for config in configurations}
                    for key in keys:
                        if key in found_keys:
                            config = next(c for c in configurations if c.key == key)
                            configuration_key.append({
                                "key": config.key,
                                "readonly": config.readonly,
                                "value": config.value
                            })
                        else:
                            unknown_key.append(key)
                else:
                    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –≤—Å–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
                    for config in configurations:
                        configuration_key.append({
                            "key": config.key,
                            "readonly": config.readonly,
                            "value": config.value
                        })
                
            return call_result.GetConfiguration(
                configuration_key=configuration_key,
                unknown_key=unknown_key if unknown_key else None
            )
            
        except Exception as e:
            self.logger.error(f"Error in GetConfiguration: {e}")
            return call_result.GetConfiguration(
                configuration_key=[],
                unknown_key=keys if keys else []
            )

    @on('ChangeConfiguration')
    def on_change_configuration(self, key, value, **kwargs):
        """–ò–∑–º–µ–Ω–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤"""
        self.logger.info(f"ChangeConfiguration: {key} = {value}")
        
        try:
            with next(get_db()) as db:
                result = OCPPConfigurationService.change_configuration(
                    db, self.id, key, value
                )
                
            status = result.get("status", "Rejected")
            self.logger.info(f"ChangeConfiguration result: {status}")
            
            return call_result.ChangeConfiguration(
                status=ConfigurationStatus[status.lower()]
            )
            
        except Exception as e:
            self.logger.error(f"Error in ChangeConfiguration: {e}")
            return call_result.ChangeConfiguration(
                status=ConfigurationStatus.rejected
            )

    @on('Reset')
    def on_reset(self, type, **kwargs):
        """–ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ —Å—Ç–∞–Ω—Ü–∏–∏"""
        self.logger.info(f"Reset request: {type}")
        
        try:
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ reset –≤ –ë–î
            with next(get_db()) as db:
                OCPPStationService.update_station_status(
                    db, self.id, "Unavailable", "Reset", f"Reset {type} requested"
                )
            
            # –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –º–æ–∂–µ—Ç –±—ã—Ç—å –ª–æ–≥–∏–∫–∞
            # –¥–ª—è –∏–Ω–∏—Ü–∏–∞—Ü–∏–∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞ —Å—Ç–∞–Ω—Ü–∏–∏
            
            return call_result.Reset(status=ResetStatus.accepted)
            
        except Exception as e:
            self.logger.error(f"Error in Reset: {e}")
            return call_result.Reset(status=ResetStatus.rejected)

    @on('UnlockConnector')
    def on_unlock_connector(self, connector_id, **kwargs):
        """–†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–∞"""
        self.logger.info(f"UnlockConnector request for connector: {connector_id}")
        
        try:
            # –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è
            # –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–∞
            
            with next(get_db()) as db:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∞–∫—Ç–∏–≤–Ω–æ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
                active_transaction = db.query(OCPPTransaction).filter(
                    OCPPTransaction.station_id == self.id,
                    OCPPTransaction.status == "started"
                ).first()
                
                if active_transaction:
                    # –ï—Å—Ç—å –∞–∫—Ç–∏–≤–Ω–∞—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è - –Ω–µ –º–æ–∂–µ–º —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å
                    return call_result.UnlockConnector(
                        status=UnlockStatus.not_supported
                    )
            
            return call_result.UnlockConnector(status=UnlockStatus.unlocked)
            
        except Exception as e:
            self.logger.error(f"Error in UnlockConnector: {e}")
            return call_result.UnlockConnector(status=UnlockStatus.unlock_failed)

    # ============================================================================
    # TIER 2: –í–ê–ñ–ù–´–ï –î–õ–Ø PRODUCTION
    # ============================================================================

    @on('DataTransfer')
    def on_data_transfer(self, vendor_id, **kwargs):
        """–ö–∞—Å—Ç–æ–º–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—è"""
        message_id = kwargs.get('message_id', '')
        data = kwargs.get('data', '')
        
        self.logger.info(f"DataTransfer: vendor_id={vendor_id}, message_id={message_id}")
        
        try:
            # –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫—É –∫–∞—Å—Ç–æ–º–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
            # –í –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç vendor_id –∏ message_id
            
            return call_result.DataTransfer(
                status="Accepted",
                data=f"Received: {data}"
            )
            
        except Exception as e:
            self.logger.error(f"Error in DataTransfer: {e}")
            return call_result.DataTransfer(status="Rejected")

    @on('DiagnosticsStatusNotification')
    def on_diagnostics_status_notification(self, status, **kwargs):
        """–°—Ç–∞—Ç—É—Å –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏"""
        self.logger.info(f"DiagnosticsStatusNotification: status={status}")
        
        try:
            with next(get_db()) as db:
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ç—É—Å –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏ –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
                OCPPConfigurationService.set_configuration(
                    db, self.id, "DiagnosticsStatus", status
                )
                
            return call_result.DiagnosticsStatusNotification()
            
        except Exception as e:
            self.logger.error(f"Error in DiagnosticsStatusNotification: {e}")
            return call_result.DiagnosticsStatusNotification()

    @on('FirmwareStatusNotification')
    def on_firmware_status_notification(self, status, **kwargs):
        """–°—Ç–∞—Ç—É—Å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—Ä–æ—à–∏–≤–∫–∏"""
        self.logger.info(f"FirmwareStatusNotification: status={status}")
        
        try:
            with next(get_db()) as db:
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø—Ä–æ—à–∏–≤–∫–∏
                station_status = OCPPStationService.get_station_status(db, self.id)
                if station_status:
                    if status == FirmwareStatus.installed:
                        # –ü—Ä–æ—à–∏–≤–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ
                        station_status.firmware_version = "Updated"
                    elif status == FirmwareStatus.installation_failed:
                        # –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
                        station_status.error_code = "FirmwareUpdateFailed"
                    
                    db.commit()
                
            return call_result.FirmwareStatusNotification()
            
        except Exception as e:
            self.logger.error(f"Error in FirmwareStatusNotification: {e}")
            return call_result.FirmwareStatusNotification()

    # ============================================================================
    # TIER 2: –†–ê–°–®–ò–†–ï–ù–ù–´–ï (–≤–∞–∂–Ω—ã–µ –¥–ª—è production)
    # ============================================================================

    @on('ChangeAvailability')
    def on_change_availability(self, connector_id, type, **kwargs):
        """–ò–∑–º–µ–Ω–µ–Ω–∏–µ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ —Å—Ç–∞–Ω—Ü–∏–∏/–∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–∞"""
        self.logger.info(f"ChangeAvailability: connector={connector_id}, type={type}")
        
        try:
            with next(get_db()) as db:
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞
                if type == AvailabilityType.operative:
                    new_status = "Available"
                else:  # inoperative
                    new_status = "Unavailable"
                
                OCPPStationService.update_station_status(
                    db, self.id, new_status, None, f"Availability changed to {type}"
                )
            
            return call_result.ChangeAvailability(
                status=AvailabilityStatus.accepted
            )
            
        except Exception as e:
            self.logger.error(f"Error in ChangeAvailability: {e}")
            return call_result.ChangeAvailability(
                status=AvailabilityStatus.rejected
            )

    @on('ClearCache')
    def on_clear_cache(self, **kwargs):
        """–û—á–∏—Å—Ç–∫–∞ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∫—ç—à–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"""
        self.logger.info("ClearCache request")
        
        try:
            with next(get_db()) as db:
                # –ü–æ–º–µ—á–∞–µ–º –≤—Å–µ –ª–æ–∫–∞–ª—å–Ω—ã–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –∫–∞–∫ —É—Å—Ç–∞—Ä–µ–≤—à–∏–µ
                expired_auths = db.query(OCPPAuthorization).filter(
                    OCPPAuthorization.station_id == self.id,
                    OCPPAuthorization.is_local == True
                ).all()
                
                for auth in expired_auths:
                    auth.expires_at = datetime.utcnow()  # –ü–æ–º–µ—á–∞–µ–º –∫–∞–∫ –∏—Å—Ç–µ–∫—à–∏–µ
                
                db.commit()
                
            self.logger.info(f"Cleared {len(expired_auths)} local authorizations")
            return call_result.ClearCache(status=ClearCacheStatus.accepted)
            
        except Exception as e:
            self.logger.error(f"Error in ClearCache: {e}")
            return call_result.ClearCache(status=ClearCacheStatus.rejected)

    @on('GetDiagnostics')
    def on_get_diagnostics(self, location, **kwargs):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö"""
        retries = kwargs.get('retries', 1)
        retry_interval = kwargs.get('retry_interval', 60)
        start_time = kwargs.get('start_time')
        stop_time = kwargs.get('stop_time')
        
        self.logger.info(f"GetDiagnostics request to location: {location}")
        
        try:
            # –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –ø—Ä–æ—Ü–µ—Å—Å
            # —Å–±–æ—Ä–∞ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö
            
            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏–º—è —Ñ–∞–π–ª–∞ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
            filename = f"diagnostics_{self.id}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.log"
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∑–∞–ø—Ä–æ—Å–µ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
            with next(get_db()) as db:
                OCPPConfigurationService.set_configuration(
                    db, self.id, "DiagnosticsLocation", location
                )
                OCPPConfigurationService.set_configuration(
                    db, self.id, "DiagnosticsFilename", filename
                )
            
            return call_result.GetDiagnostics(file_name=filename)
            
        except Exception as e:
            self.logger.error(f"Error in GetDiagnostics: {e}")
            return call_result.GetDiagnostics(file_name=None)

    @on('UpdateFirmware')
    def on_update_firmware(self, location, retrieve_date, **kwargs):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ—à–∏–≤–∫–∏"""
        retries = kwargs.get('retries', 1)
        retry_interval = kwargs.get('retry_interval', 60)
        
        self.logger.info(f"UpdateFirmware request: {location} at {retrieve_date}")
        
        try:
            # –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –ø–ª–∞–Ω–∏—Ä—É–µ—Ç—Å—è –∑–∞–≥—Ä—É–∑–∫–∞
            # –∏ —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–æ–≤–æ–π –ø—Ä–æ—à–∏–≤–∫–∏
            
            with next(get_db()) as db:
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏
                OCPPConfigurationService.set_configuration(
                    db, self.id, "FirmwareUpdateLocation", location
                )
                OCPPConfigurationService.set_configuration(
                    db, self.id, "FirmwareUpdateDate", retrieve_date
                )
                
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å —Å—Ç–∞–Ω—Ü–∏–∏
                OCPPStationService.update_station_status(
                    db, self.id, "Unavailable", None, "Firmware update scheduled"
                )
            
            return call_result.UpdateFirmware()
            
        except Exception as e:
            self.logger.error(f"Error in UpdateFirmware: {e}")
            return call_result.UpdateFirmware()

    # ============================================================================ 
    # TIER 3: –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï (–ø–æ–ª–µ–∑–Ω—ã–µ –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞)
    # ============================================================================

    @on('TriggerMessage')
    def on_trigger_message(self, requested_message, **kwargs):
        """–ó–∞–ø—Ä–æ—Å –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è"""
        connector_id = kwargs.get('connector_id')
        
        self.logger.info(f"TriggerMessage: {requested_message} for connector {connector_id}")
        
        try:
            # –í –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç requested_message –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
            if requested_message == MessageTrigger.boot_notification:
                # –ü–ª–∞–Ω–∏—Ä—É–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É BootNotification
                pass
            elif requested_message == MessageTrigger.heartbeat:
                # –ü–ª–∞–Ω–∏—Ä—É–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É Heartbeat
                pass
            elif requested_message == MessageTrigger.status_notification:
                # –ü–ª–∞–Ω–∏—Ä—É–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É StatusNotification
                pass
            elif requested_message == MessageTrigger.meter_values:
                # –ü–ª–∞–Ω–∏—Ä—É–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É MeterValues
                pass
            
            return call_result.TriggerMessage(
                status=TriggerMessageStatus.accepted
            )
            
        except Exception as e:
            self.logger.error(f"Error in TriggerMessage: {e}")
            return call_result.TriggerMessage(
                status=TriggerMessageStatus.rejected
            )

    @on('SendLocalList')
    def on_send_local_list(self, list_version, update_type, **kwargs):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"""
        local_authorization_list = kwargs.get('local_authorization_list', [])
        
        self.logger.info(f"SendLocalList: version={list_version}, type={update_type}")
        
        try:
            with next(get_db()) as db:
                if update_type == UpdateType.full:
                    # –ü–æ–ª–Ω–∞—è –∑–∞–º–µ–Ω–∞ —Å–ø–∏—Å–∫–∞
                    # –£–¥–∞–ª—è–µ–º –≤—Å–µ –ª–æ–∫–∞–ª—å–Ω—ã–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
                    db.query(OCPPAuthorization).filter(
                        OCPPAuthorization.station_id == self.id,
                        OCPPAuthorization.is_local == True
                    ).delete()
                
                # –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ –∑–∞–ø–∏—Å–∏
                for item in local_authorization_list:
                    id_tag = item.get('id_tag')
                    id_tag_info = item.get('id_tag_info', {})
                    
                    auth = OCPPAuthorization(
                        station_id=self.id,
                        id_tag=id_tag,
                        status=id_tag_info.get('status', 'Accepted'),
                        is_local=True,
                        expires_at=datetime.fromisoformat(id_tag_info['expiry_date']) 
                                   if id_tag_info.get('expiry_date') else None
                    )
                    db.add(auth)
                
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤–µ—Ä—Å–∏—é —Å–ø–∏—Å–∫–∞
                OCPPConfigurationService.set_configuration(
                    db, self.id, "LocalListVersion", str(list_version)
                )
                
                db.commit()
            
            return call_result.SendLocalList(status=UpdateStatus.accepted)
            
        except Exception as e:
            self.logger.error(f"Error in SendLocalList: {e}")
            return call_result.SendLocalList(status=UpdateStatus.failed)

    @on('GetLocalListVersion')
    def on_get_local_list_version(self, **kwargs):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤–µ—Ä—Å–∏–∏ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"""
        self.logger.info("GetLocalListVersion request")
        
        try:
            with next(get_db()) as db:
                configs = OCPPConfigurationService.get_configuration(
                    db, self.id, ["LocalListVersion"]
                )
                
                version = 0
                if configs:
                    try:
                        version = int(configs[0].value)
                    except (ValueError, IndexError):
                        version = 0
            
            return call_result.GetLocalListVersion(list_version=version)
            
        except Exception as e:
            self.logger.error(f"Error in GetLocalListVersion: {e}")
            return call_result.GetLocalListVersion(list_version=0)


class OCPPWebSocketHandler:
    """–û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ OCPP WebSocket –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π"""
    
    def __init__(self, station_id: str, websocket: WebSocket):
        self.station_id = station_id
        self.websocket = websocket
        self.charge_point: Optional[OCPPChargePoint] = None
        self.pubsub_task: Optional[asyncio.Task] = None
        self.logger = logging.getLogger(f"OCPPHandler.{station_id}")
        
    async def handle_connection(self):
        """–û—Å–Ω–æ–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ WebSocket –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è"""
        try:
            # –ü—Ä–∏–Ω–∏–º–∞–µ–º WebSocket –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —Å OCPP 1.6 subprotocol
            await self.websocket.accept(subprotocol="ocpp1.6")
            self.logger.info(f"Station {self.station_id} connected")
            
            # –°–æ–∑–¥–∞–µ–º –∞–¥–∞–ø—Ç–µ—Ä –¥–ª—è OCPP –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
            adapter = WebSocketAdapter(self.websocket)
            self.charge_point = OCPPChargePoint(self.station_id, adapter)
            
            # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º —Å—Ç–∞–Ω—Ü–∏—é –≤ Redis
            await redis_manager.register_station(self.station_id)
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥ –∏–∑ Redis
            self.pubsub_task = asyncio.create_task(
                self._handle_redis_commands()
            )
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º OCPP charge point
            await self.charge_point.start()
            
        except WebSocketDisconnect:
            self.logger.info(f"Station {self.station_id} disconnected")
        except Exception as e:
            self.logger.error(f"Error in WebSocket connection: {e}")
        finally:
            await self._cleanup()
    
    async def _handle_redis_commands(self):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥ –∏–∑ Redis pub/sub"""
        try:
            async for command in redis_manager.listen_commands(self.station_id):
                self.logger.info(f"Received command: {command}")
                
                if not self.charge_point:
                    continue
                    
                command_type = command.get("command")
                payload = command.get("payload", {})
                
                try:
                    if command_type == "RemoteStartTransaction":
                        response = await self.charge_point.call(
                            call.RemoteStartTransaction(
                                connector_id=payload.get("connectorId", 1),
                                id_tag=payload.get("idTag", "system")
                            )
                        )
                        self.logger.info(f"RemoteStartTransaction response: {response}")
                        
                    elif command_type == "RemoteStopTransaction":
                        session = active_sessions.get(self.station_id, {})
                        transaction_id = session.get('transaction_id', 
                                                   payload.get("transactionId", 1))
                        
                        response = await self.charge_point.call(
                            call.RemoteStopTransaction(transaction_id=transaction_id)
                        )
                        self.logger.info(f"RemoteStopTransaction response: {response}")
                        
                    elif command_type == "Reset":
                        reset_type = payload.get("type", "Soft")
                        response = await self.charge_point.call(
                            call.Reset(type=ResetType[reset_type.lower()])
                        )
                        self.logger.info(f"Reset response: {response}")
                        
                    elif command_type == "UnlockConnector":
                        connector_id = payload.get("connectorId", 1)
                        response = await self.charge_point.call(
                            call.UnlockConnector(connector_id=connector_id)
                        )
                        self.logger.info(f"UnlockConnector response: {response}")
                        
                    elif command_type == "ChangeConfiguration":
                        key = payload.get("key")
                        value = payload.get("value")
                        if key and value:
                            response = await self.charge_point.call(
                                call.ChangeConfiguration(key=key, value=value)
                            )
                            self.logger.info(f"ChangeConfiguration response: {response}")
                            
                    elif command_type == "GetConfiguration":
                        keys = payload.get("keys", [])
                        response = await self.charge_point.call(
                            call.GetConfiguration(key=keys if keys else None)
                        )
                        self.logger.info(f"GetConfiguration response: {response}")
                        
                    elif command_type == "ChangeAvailability":
                        connector_id = payload.get("connectorId", 0)
                        availability_type = payload.get("type", "Operative")
                        response = await self.charge_point.call(
                            call.ChangeAvailability(
                                connector_id=connector_id,
                                type=AvailabilityType[availability_type.lower()]
                            )
                        )
                        self.logger.info(f"ChangeAvailability response: {response}")
                        
                    elif command_type == "ClearCache":
                        response = await self.charge_point.call(call.ClearCache())
                        self.logger.info(f"ClearCache response: {response}")
                        
                    elif command_type == "GetDiagnostics":
                        location = payload.get("location", "/tmp/diagnostics.log")
                        response = await self.charge_point.call(
                            call.GetDiagnostics(location=location)
                        )
                        self.logger.info(f"GetDiagnostics response: {response}")
                        
                    elif command_type == "UpdateFirmware":
                        location = payload.get("location")
                        retrieve_date = payload.get("retrieveDate")
                        if location and retrieve_date:
                            response = await self.charge_point.call(
                                call.UpdateFirmware(
                                    location=location,
                                    retrieve_date=retrieve_date
                                )
                            )
                            self.logger.info(f"UpdateFirmware response: {response}")
                            
                    elif command_type == "TriggerMessage":
                        requested_message = payload.get("requestedMessage")
                        connector_id = payload.get("connectorId")
                        if requested_message:
                            response = await self.charge_point.call(
                                call.TriggerMessage(
                                    requested_message=MessageTrigger[requested_message.lower()],
                                    connector_id=connector_id
                                )
                            )
                            self.logger.info(f"TriggerMessage response: {response}")
                            
                except Exception as e:
                    self.logger.error(f"Error executing command {command_type}: {e}")
                    
        except Exception as e:
            self.logger.error(f"Error in Redis command handler: {e}")
    
    async def _cleanup(self):
        """–û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤ –ø—Ä–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏"""
        try:
            if self.pubsub_task:
                self.pubsub_task.cancel()
                
            await redis_manager.unregister_station(self.station_id)
            
            if self.station_id in active_sessions:
                del active_sessions[self.station_id]
                
            self.logger.info(f"Cleanup completed for station {self.station_id}")
            
        except Exception as e:
            self.logger.error(f"Error during cleanup: {e}")


class WebSocketAdapter:
    """–ê–¥–∞–ø—Ç–µ—Ä FastAPI WebSocket –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å OCPP –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π"""
    
    def __init__(self, websocket: WebSocket):
        self.websocket = websocket
    
    async def recv(self):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è"""
        return await self.websocket.receive_text()
    
    async def send(self, message):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è"""
        await self.websocket.send_text(message)
    
    async def close(self):
        """–ó–∞–∫—Ä—ã—Ç–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è"""
        await self.websocket.close() 